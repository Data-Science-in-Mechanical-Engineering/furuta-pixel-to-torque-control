"""
Generating data for training neural networks of the vision to state task

data gets generated by different SignalGenerators. The frames are recorded by the camera and the states of the Qube
are saved in a csv file.
Images and csv rows are distinguished by its logID.   The size of
the dataset can be adjust with the duration parameter.

@Author: Steffen Bleher
"""

import csv
import os
import pandas as pd
from tqdm import tqdm

import cv2
import numpy as np
from gym_brt.data.config.configuration import FREQUENCY
from gym_brt.envs.reinforcementlearning_extensions.rl_gym_classes import convert_state_back

from gym_brt.envs.reinforcementlearning_extensions.vision_wrapping_classes import VisionQubeBeginDownEnv
from visiontostate.data_generator_functions import SmallAlphaBiasGenerator, FullSpaceGenerator


class DataCollector:

    def __init__(self, data_id, frequency=FREQUENCY):
        self.data_id = data_id
        self.frequency = frequency
        my_path = os.path.abspath(os.path.dirname(__file__))
        self.data_path = os.path.join(my_path, '../../data/visiontostate')

        self.create_data_logging_structure()

        self.env = VisionQubeBeginDownEnv(use_simulator=False, simulation_mode=None, frequency=self.frequency, integration_steps=1, no_image_normalization=True,)

    def __enter__(self):
        return self

    def __exit__(self, type, value, traceback):
        self.env.__exit__(type, value, traceback)

    def create_data_logging_structure(self):
        path = self.data_path
        if self.data_id == -1:
            self.data_id = 0
            for (_, dirs, _) in os.walk(path):
                for dirname in dirs:
                    if int(dirname) >= self.data_id:
                        self.data_id = int(dirname) + 1
                break
            self.log_id = 0
            path += ("/" + str(self.data_id).zfill(3))

            if not os.path.exists(path):
                os.mkdir(path)
            if not os.path.exists(path + "/img"):
                os.mkdir(path + "/img")
            if not os.path.exists(path + "/aug"):
                os.mkdir(path + "/aug")
            if not os.path.exists(path + "/tb"):
                os.mkdir(path + "/tb")
        else:
            path += ("/" + str(self.data_id).zfill(3))
            self.log_id = int(pd.read_csv(path + '/angles.csv', header=None, error_bad_lines=False).iloc[-1, 0].split('.')[0]) + 1

        print("DataID: " + str(self.data_id))
        print("LogID: " + str(self.log_id))
        self.data_path = path

    def _save_image(self, image, log_id, path, alpha, theta):
        # filepath = path + "/" + log_id + "_alpha=" + str(alpha) + "_theta=" + str(theta) + ".png"
        filepath = path + "/" + log_id + ".png"
        cv2.imwrite(filepath, image)

    # def _find_offset_voltage(self, theta_ref=0):
    #     state, reward, done, info = self.env.step(np.array([0], dtype=np.float64))
    #     encoder_state = [info['theta'], info['alpha'], info['theta_dot'], info['alpha_dot']]
    #     theta = encoder_state[0]
    #
    #     voltage = 0.0
    #
    #     voltage_sign = 1
    #     if theta_ref < theta:
    #         voltage_sign = -1
    #
    #     while (voltage_sign*theta < voltage_sign*theta_ref):
    #         voltage -= voltage_sign*0.0002
    #         state, reward, done, info = self.env.step(np.array([voltage], dtype=np.float64))
    #         encoder_state = [info['theta'], info['alpha'], info['theta_dot'], info['alpha_dot']]
    #         theta = encoder_state[0]
    #
    #     return voltage

    def _hold_voltage(self, voltage):
        for i in range(self.frequency*10):
            self.env.step(np.array([voltage], dtype=np.float64))

    def _record_sample(self, writer, ctrl_sys, encoder_state, pbar):
        action = ctrl_sys.action(convert_state_back(encoder_state))
        # get feedback
        state, reward, done, info = self.env.step(action)
        encoder_state = [info['theta'], info['alpha'], info['theta_dot'], info['alpha_dot']]
        alpha = info['alpha']
        theta = info['theta']

        state_to_log = [np.cos(theta), np.sin(theta), np.cos(alpha), np.sin(alpha), info['theta_dot'],
                        info['alpha_dot']]

        # store data
        if ctrl_sys.step >= ctrl_sys.sample_freq * ctrl_sys.t_start:
            writer.writerow(
                [str(self.log_id).zfill(6) + ".png", state_to_log[0], state_to_log[1], state_to_log[2],
                 state_to_log[3],
                 state_to_log[4], state_to_log[5]])
            self._save_image(state, str(self.log_id).zfill(6), self.data_path + "/img", alpha, theta)
            self.log_id += 1
            pbar.update(1)
        return encoder_state

    def run(self, duration=1680, up_bias=4/7):
        self.env.reset()

        # breaks
        break_theta_neutral = int(self.frequency * duration * (1 - up_bias))
        break_up = break_theta_neutral + int(self.frequency * duration * up_bias)

        pbar = tqdm(total=break_up)
        pbar.n = self.log_id
        pbar.refresh()

        with open(self.data_path + "/angles.csv", mode='a') as angle_file:
            writer = csv.writer(angle_file, delimiter=',', quotechar='"', quoting=csv.QUOTE_MINIMAL)

            state, reward, done, info = self.env.step(np.array([0], dtype=np.float64))
            encoder_state = [info['theta'], info['alpha'], info['theta_dot'], info['alpha_dot']]

            if (self.log_id < break_theta_neutral):
                self.env.reset()
                ctrl_sys = FullSpaceGenerator(self.env, sample_freq=self.frequency)
                while (self.log_id < break_theta_neutral):
                    encoder_state = self._record_sample(writer, ctrl_sys, encoder_state, pbar)

            if (self.log_id < break_up):
                self.env.reset()
                ctrl_sys = SmallAlphaBiasGenerator(self.env, sample_freq=self.frequency)
                while (self.log_id < break_up):
                    encoder_state = self._record_sample(writer, ctrl_sys, encoder_state, pbar)